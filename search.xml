<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>wtfpython day2</title>
    <url>/2020/03/23/wtfpython-day2/</url>
    <content><![CDATA[<h3 id="The-surprising-comma"><a href="#The-surprising-comma" class="headerlink" title="The surprising comma"></a>The surprising comma</h3><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y,)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x, y)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x=<span class="number">4</span>, y=<span class="number">5</span>,)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(x, y)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x, **kwargs,)</span>:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x, **kwargs,)</span>:</span></span><br><span class="line">                     ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(*args,)</span>:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(*args,)</span>:</span></span><br><span class="line">                ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<ul>
<li>在Python函数的形参列表中，尾随逗号并不一定是合法的。</li>
<li>在Python中，参数列表部分用前置逗号定义，部分用尾随逗号定义。这种冲突导致逗号被夹在中间，没有规则定义它。</li>
<li><strong>Python3.6已修复</strong></li>
</ul>
<h3 id="Backslashes-at-the-end-string"><a href="#Backslashes-at-the-end-string" class="headerlink" title="Backslashes at the end string"></a>Backslashes at the end string</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"\\ C:\\"</span>)</span><br><span class="line">\ C:\</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r"\ C:"</span>)</span><br><span class="line">\ C:</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r"\ C:\")</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    File "</span>&lt;stdin&gt;<span class="string">", line 1</span></span><br><span class="line"><span class="string">      print(r"</span>\ C:\<span class="string">")</span></span><br><span class="line"><span class="string">                     ^</span></span><br><span class="line"><span class="string">SyntaxError: EOL while scanning string literal</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解释器只是简单的改变了反斜杠的行为，因此会直接放行反斜杠以及后一个的字符。<strong>所以</strong>反斜杠在原始字符串末尾不起作用。</li>
</ul>
<h3 id="not-knot！"><a href="#not-knot！" class="headerlink" title="not knot！"></a>not knot！</h3><ul>
<li>运算符的优先级会影响表达式的求值顺序，而在Python中==运算符的优先级要高于not运算符。</li>
</ul>
<h3 id="Half-triple-quoted-strings"><a href="#Half-triple-quoted-strings" class="headerlink" title="Half triple-quoted strings"></a>Half triple-quoted strings</h3><ul>
<li><p>Python提供隐式的字符串连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtf"</span> <span class="string">"python"</span>)</span><br><span class="line">wtfpython</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"wtf"</span> <span class="string">""</span>) <span class="comment"># or "wtf"""</span></span><br><span class="line">wtf</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;&#39;&#39;</code>和<code>“”“</code>在Python中也是字符串定界符，Python解释器在先遇到三个引号的时候会尝试再寻找三个终止引号作为定界符，若不存在则会导致 <code>SyntaxError</code>异常。</p>
</li>
</ul>
<h3 id="Midnight-time-doesn‘t-exist？"><a href="#Midnight-time-doesn‘t-exist？" class="headerlink" title="Midnight time doesn‘t exist？"></a>Midnight time doesn‘t exist？</h3><ul>
<li>在Python<strong>3.5</strong>之前，如果<code>datetime.time</code>对象存储的UTC的午夜时间（即00：00），那么它的布尔值会被认为是False。</li>
</ul>
<h3 id="What’s-wrong-with-booleans？"><a href="#What’s-wrong-with-booleans？" class="headerlink" title="What’s wrong with booleans？"></a>What’s wrong with booleans？</h3><ul>
<li><p>布尔值是int的子类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="literal">True</span>, int)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="literal">False</span>, int)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>True的整数值是1，False的整数值是0。</p>
</li>
</ul>
<h3 id="Class-attributes-and-instance-attributes"><a href="#Class-attributes-and-instance-attributes" class="headerlink" title="Class attributes and instance attributes"></a>Class attributes and instance attributes</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    some_var = <span class="number">15</span></span><br><span class="line">    some_list = [<span class="number">5</span>]</span><br><span class="line">    another_list = [<span class="number">5</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.some_var = x + <span class="number">1</span></span><br><span class="line">        self.some_list = self.some_list + [x]</span><br><span class="line">        self.another_list += [x]</span><br><span class="line">        </span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj = SomeClass(<span class="number">420</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj.some_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_obj.another_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj = SomeClass(<span class="number">111</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.some_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">111</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list</span><br><span class="line">[<span class="number">5</span>, <span class="number">420</span>, <span class="number">111</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list <span class="keyword">is</span> SomeClass.another_list</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_obj.another_list <span class="keyword">is</span> some_obj.another_list</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类变量和实例变量在内部是通过类对象的字典来处理(__ dict __属性)。如果在当前类的字典中找不到的话，就去父类中寻找。</li>
<li>+=运算符会在原地修改可变对象，而不是创建新对象。因此，在这种情况下，修改一个实例的属性会影响其他实例和类属性。</li>
</ul>
<h3 id="Yielding-None"><a href="#Yielding-None" class="headerlink" title="Yielding None"></a>Yielding None</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_iterable = (<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"something"</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable]</span><br><span class="line">&lt;generator object &lt;listcomp&gt; at <span class="number">0x7f70b0a4ad58</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list([(<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable])</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list((<span class="keyword">yield</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable)</span><br><span class="line">[<span class="string">'a'</span>, <span class="literal">None</span>, <span class="string">'b'</span>, <span class="literal">None</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(some_func((<span class="keyword">yield</span> x)) <span class="keyword">for</span> x <span class="keyword">in</span> some_iterable)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'something'</span>, <span class="string">'b'</span>, <span class="string">'something'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>只是一个有趣的bug，<strong>不建议使用。</strong></li>
</ul>
<h3 id="Mutating-the-immutable"><a href="#Mutating-the-immutable" class="headerlink" title="Mutating the immutable!"></a>Mutating the immutable!</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_tuple = (<span class="string">"A"</span>, <span class="string">"tuple"</span>, <span class="string">"with"</span>, <span class="string">"values"</span>)</span><br><span class="line">another_tuple = ([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>some_tuple[<span class="number">2</span>] = <span class="string">"change this"</span></span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple[<span class="number">2</span>].append(<span class="number">1000</span>) <span class="comment"># 这里不出现错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple[<span class="number">2</span>] += [<span class="number">99</span>, <span class="number">999</span>]</span><br><span class="line">TypeError: <span class="string">'tuple'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>another_tuple</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">1000</span>, <span class="number">99</span>, <span class="number">999</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>+=操作符在原地修改了列表，元素赋值操作并不工作，但是当异常抛出时，元素已经在原地被修改了。</li>
</ul>
<h3 id="The-disappearing-variable-from-outer-scope"><a href="#The-disappearing-variable-from-outer-scope" class="headerlink" title="The disappearing variable from outer scope"></a>The disappearing variable from outer scope</h3><ul>
<li>当使用<code>as</code>为目标分配异常的时候，将在except子句的末尾清楚该异常。</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>wtfpython day1</title>
    <url>/2020/03/22/wtfpython-day1/</url>
    <content><![CDATA[<h3 id="字符串驻留"><a href="#字符串驻留" class="headerlink" title="字符串驻留"></a>字符串驻留</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul>
<li>字符串驻留是一种仅保存一份相同且不可变字符串的方法</li>
</ul>
<blockquote>
<p>基本原理：</p>
<p>系统维护intered字典，记录已被驻留的字符串对象。</p>
<p>当字符串对象a需要驻留时，现在interned检测是否存在，若存在则指向存在的字符串对象，a的引用计数减1；</p>
<p>若不存在，则记录a到interned中。</p>
</blockquote>
<a id="more"></a>

<h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul>
<li>节省大量内存</li>
<li>字符串比较时，非驻留比较效率o(n),驻留时比较效率o(1)。</li>
</ul>
<h5 id="驻留情况"><a href="#驻留情况" class="headerlink" title="驻留情况"></a>驻留情况</h5><ul>
<li><p>字符串只在编译时进行驻留，而非运行时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"hello"</span> + <span class="string">"world"</span></span><br><span class="line">print(<span class="string">"compile:"</span>,a <span class="keyword">is</span> <span class="string">"helloworld"</span>)</span><br><span class="line"></span><br><span class="line">a= <span class="string">"hello"</span></span><br><span class="line">b = <span class="string">"world"</span></span><br><span class="line">print(<span class="string">"run:"</span>,a+b <span class="keyword">is</span> <span class="string">"helloworld"</span>)</span><br><span class="line"><span class="comment">#compile : True</span></span><br><span class="line"><span class="comment">#run : False</span></span><br></pre></td></tr></table></figure>

<p><em>‘wtf’将被驻留，但是’’.join([‘w’,’t’,’f’])不会被驻留</em></p>
</li>
<li><p>字符串长度为0和1时，默认都采用了驻留机制。</p>
</li>
<li><p>字符串&gt;1时，且只含大小写字母、数字、下划线时，才会默认驻留。</p>
</li>
<li><p>用乘法得到的字符串，有2种情况。</p>
<ul>
<li>乘数为1时，都是默认驻留。</li>
<li>乘数&gt;=2时：<ul>
<li>仅含大小写字母、数字、下划线，长度&lt;=20，默认驻留</li>
<li>仅含大小写字母、数字、下划线，长度&gt;20，默认不驻留</li>
<li>其他字符串时，与长度无关，不驻留。</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串被sys.intern()指定驻留。</p>
</li>
<li><p>[-5,256]之间的整数数字，Python默认驻留。</p>
</li>
</ul>
<h3 id="Time-for-some-hash-brownies"><a href="#Time-for-some-hash-brownies" class="headerlink" title="Time for some hash brownies!"></a>Time for some hash brownies!</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> == <span class="number">5.0</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash(<span class="number">5</span>) == hash(<span class="number">5.0</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Python字典通过检查<strong>键值是否相等</strong>和<strong>比较哈希值</strong>来去确定两个键是否相同。</p>
</li>
<li><p>具有相同值的不可变对象在Python中始终具有相同的哈希值。</p>
<blockquote>
<p>具有不同值的对象也可能具有相同的哈希值（哈希冲突）</p>
</blockquote>
</li>
</ul>
<h3 id="Return-return-everyone！"><a href="#Return-return-everyone！" class="headerlink" title="Return return everyone！"></a>Return return everyone！</h3><ul>
<li>函数的 返回值由最后执行的return语句决定。</li>
</ul>
<h3 id="Deep-down，we’re-all-the-same"><a href="#Deep-down，we’re-all-the-same" class="headerlink" title="Deep down，we’re all the same."></a>Deep down，we’re all the same.</h3><ul>
<li>对象的id值仅仅在对象的生命周期内唯一，在对象被<strong>销毁之后</strong>，或被<strong>创建之前</strong>，其他对象也可以具有相同的id值。</li>
</ul>
<h3 id="For-what？"><a href="#For-what？" class="headerlink" title="For what？"></a>For what？</h3><ul>
<li><p>for的定义</p>
<blockquote>
<p>for_stmt: ‘for’ exprlist ‘in’ testlist ‘:’ suite [‘else’ ‘:’ suite]</p>
<p>其中exprlist指分配目标，这意味着对可迭代对象中的<strong>每一项都会执行</strong>类似{exprlist} = {next_value}的操作。</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">	print(i)</span><br><span class="line">	i = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>由于for的工作机制，每一次i都会被赋值，所以i=10对循环无作用。</p>
<h3 id="Evaluation-time-discrepancy"><a href="#Evaluation-time-discrepancy" class="headerlink" title="Evaluation time discrepancy"></a>Evaluation time discrepancy</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">15</span>]</span><br><span class="line">g = (x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> array.count(x) &gt; <span class="number">0</span>)</span><br><span class="line">array = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">22</span>]</span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g))</span><br><span class="line">[<span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>in子句在声明时执行，而条件子句在运行时执行。在上述代码中，x属于{1，8，15}，而array被重新赋值为[2,8,22]，所以出现的只有8。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g1 = (x <span class="keyword">for</span> x <span class="keyword">in</span> array_1)</span><br><span class="line">array_1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">array_2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">g2 = (x <span class="keyword">for</span> x <span class="keyword">in</span> array_2)</span><br><span class="line">array_2[:] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g1))</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(g2))</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>array_1被绑定到新对象[1,2,3,4,5]，因为in子句在声明时执行，所以它仍然引用旧对象[1,2,3,4]。</li>
<li>对array_2的切片赋值将相同的旧对象更新为[1,2,3,4,5]，因此g2和array_2引用同一个对象。</li>
</ul>
<h3 id="is-is-not-what-it-is！"><a href="#is-is-not-what-it-is！" class="headerlink" title="is is not what it is！"></a>is is not what it is！</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span>; b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>is运算符检查两个运算对象是否引用自同一对象。<em>引用是否相同</em></p>
</li>
<li><p>==运算符比较两个运算对象的值是否相等。<em>值是否相等</em></p>
</li>
<li><p>Python通过创建小整数池(-5~256)来避免小整数频繁的申请和销毁内存空间。</p>
</li>
<li><p>当a和b在同一行使用相同的值初始化时，会指向同一个对象。(命令行交互)。</p>
</li>
</ul>
<h3 id="A-tic-tac-toe-where-X-wins-in-the-first-attempt"><a href="#A-tic-tac-toe-where-X-wins-in-the-first-attempt" class="headerlink" title="A tic-tac-toe where X wins in the first attempt!"></a>A tic-tac-toe where X wins in the first attempt!</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们先初始化一个变量row</span></span><br><span class="line">row = [<span class="string">""</span>]*<span class="number">3</span> <span class="comment">#row i['', '', '']</span></span><br><span class="line"><span class="comment"># 并创建一个变量board</span></span><br><span class="line">board = [row]*<span class="number">3</span></span><br><span class="line"><span class="comment">#Output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>]</span><br><span class="line">[<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">"X"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>board</span><br><span class="line">[[<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>], [<span class="string">'X'</span>, <span class="string">''</span>, <span class="string">''</span>]]</span><br></pre></td></tr></table></figure>

<ul>
<li>当通过对row做乘法来初始化board时，每个元素board[0],board[1],board[2]都和row一样引用了同一列表。</li>
</ul>
<h3 id="The-sticky-output-function"><a href="#The-sticky-output-function" class="headerlink" title="The sticky output function"></a>The sticky output function</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">funcs = []</span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    funcs.append(some_func)</span><br><span class="line">    results.append(some_func()) <span class="comment"># 注意这里函数被执行了</span></span><br><span class="line"></span><br><span class="line">funcs_results = [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>results</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results</span><br><span class="line">[<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当在循环内部定义一个函数时, 如果该函数在其主体中使用了循环变量, 则<strong>闭包函数将与循环变量绑定</strong>, 而不是它的值. 因此, 所有的函数都是使用最后分配给变量的值来进行计算的。</p>
</li>
<li><p>可以通过将循环变量作为命名变量传递给函数来获得预期的结果. <strong>为什么这样可行?</strong> 因为这会在函数内再次定义一个局部变量.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">funcs = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_func</span><span class="params">(x=x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    funcs.append(some_func)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results = [func() <span class="keyword">for</span> func <span class="keyword">in</span> funcs]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>funcs_results</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="is-not-…-is-not-is-not-…"><a href="#is-not-…-is-not-is-not-…" class="headerlink" title="is not … is not is (not …)"></a><em>is not …</em> is not <em>is (not …)</em></h3><ul>
<li>is not是个单独的二元运算符，与分别使用is和not不同。</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python廖雪峰笔记</title>
    <url>/2020/03/21/python%E5%BB%96%E9%9B%AA%E5%B3%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul>
<li>list和tuple是python内置的有序集合，一个可变，一个不可变。<ul>
<li>不可变的tuple使得代码更加安全，所以可能的话，能用tuple代替list就尽量用tuple。</li>
<li>要创建一个内容不变的tuple，必须保证tuple的每一个元素本身也不能变。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>list、tuple、dictionary、set</p>
<ul>
<li><p>list []</p>
</li>
<li><p>tule ()</p>
</li>
<li><p>dictionary {}</p>
</li>
<li><p>set ([])  <em>数学意义上的无序和无重复元素的集合</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样保证了不可变对象本身永远是不可变的。</p>
</li>
<li><p>参数</p>
<ul>
<li>默认参数必须指向不变对象。</li>
<li>定义可变参数和定义一个list和tuple参数对比，仅仅在参数前面加了一个*号，而函数内部，参数接收到的是一个tuple。<ul>
<li>*nums表示把nums这个list的所有元素作为可变参数传进去。</li>
</ul>
</li>
<li>（**）关键字参数在函数内部自动组装成一个dict。</li>
<li>命名关键字参数：在参数之前加个*作间隔， *后面的全部都是命名关键字参数。-</li>
<li>参数定义的顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong></li>
</ul>
</li>
<li><p>切片操作（取指定索引范围的操作</p>
</li>
<li><p>在一个列表生成式中，for前面的if…else是<strong>表达式</strong>，而for后面的if是<strong>过滤条件</strong>，不能带else。</p>
</li>
<li><p>generator</p>
<ul>
<li>把列表生成式的[]改成().</li>
<li>如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator</li>
</ul>
</li>
<li><p>迭代</p>
<ul>
<li>凡是可作用于for循环的对象都是Iterable类型；</li>
<li>凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；</li>
<li>集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。</li>
</ul>
</li>
<li><p>map/reduce</p>
<ul>
<li>map作为高阶函数，接收两个参数，一个是函数，一个是Iterable，把运算规则<strong>抽象化</strong>。</li>
<li>reduce把一个函数作用在一个序列[x1,x2,x3,…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素作累计计算。</li>
</ul>
</li>
<li><p>filter()用于过滤序列，也是接收一个函数和一个序列，filter()把传入的函数依次作用域每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
</li>
<li><p>sorted()也是一个高阶函数，可以实现排序。</p>
</li>
<li><p>返回闭包牢记一点：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<ul>
<li>闭包无法修改外部函数的局部变量。 </li>
<li>python循环中不包含域的概念。</li>
</ul>
</li>
<li><p>lambda表示匿名函数，冒号前面表示函数参数，只能有一个表达式，但是，<strong><em>Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。</em></strong></p>
</li>
<li><p>decorator</p>
<ul>
<li>在OOP的设计模式中，decorator被称为装饰模式，OOP的装饰模式需要通过继承和组合来实现。而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。</li>
<li>可以用函数实现，也可以用类实现。</li>
</ul>
</li>
<li><p>functools.partial</p>
<ul>
<li><p>把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">int2 = functools.partial(int, base=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建偏函数时，实际上可以接收函数对象、<em>args和*</em>kw这3个参数</p>
</li>
</ul>
</li>
<li><p>模块是一组Python代码的集合，可以使用其他模块，也可以被其他模块使用。</p>
</li>
<li><p>创建自己的模块时，要注意：</p>
<ul>
<li>模块名要遵循Python变量命名规范，不使用中文、特殊字符；</li>
<li>模块名不要和系统模块名冲突，最好先查看系统是否存在该模块，检查方法时在Python交互环境执行import xxx，若成功则说明系统存在此模块。</li>
</ul>
</li>
<li><p>任何模块代码的第一个字符串都被视为模块的文档注释。</p>
</li>
</ul>
<h4 id="OOR"><a href="#OOR" class="headerlink" title="OOR"></a>OOR</h4><ul>
<li><p>一些基本概念</p>
<ul>
<li><p>类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都互相独立，互不影响</p>
</li>
<li><p>方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据</p>
</li>
<li><p><strong>和静态语言不同</strong>，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">'Bart Simpson'</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lisa = Student(<span class="string">'Lisa Simpson'</span>, <span class="number">87</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.age = <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.age</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lisa.age</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'Student'</span> object has no attribute <span class="string">'age'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在Python中，实例的变量名如果以__开头，就变成了一个私有变量。</p>
</li>
<li><p>而变量名如果以双下划线开头，并且以双下划线结尾的，时特殊变量，特殊变量可以直接访问，不是private变量。</p>
</li>
</ul>
</li>
<li><p>继承可以把父类的所有功能都直接拿过来，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写。</p>
</li>
<li><p>动态语言的鸭子类型特点决定了继承不像静态语言那样是必须的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_twice</span><span class="params">(animal)</span>:</span> animal.run() animal.run()</span><br></pre></td></tr></table></figure>

<ul>
<li>由于动态语言的鸭子类型特点，这个函数写在类的外面时，任何定义的拥有run方法的类以及他的子类都可以来使用run twice这个函数。</li>
</ul>
</li>
<li><p><strong>开闭原则</strong>：</p>
<ul>
<li>对拓展开放：允许新增Animal子类。</li>
<li>对修改封闭：不需要修改以来Animal类型的run_twice()等函数。</li>
</ul>
</li>
<li><p>只有不知道对象信息的时候，才会去获取对象信息。</p>
</li>
<li><p>编写程序时，不要对实例属性和类属性使用相同的名字，因为<strong>相同名称的实例属性讲屏蔽掉类属性</strong>，而删除实例属性后，再使用相同的名称，访问到的将是类属性。</p>
</li>
<li><p>__ slots __ 变量可以用来限制class实例能添加的属性。</p>
<ul>
<li>该变量定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。</li>
<li>除非在子类中也定义__ slots __ ，这样，子类实例允许定义的属性就是自身的 __ slots __ 加上父亲的 __ slots __。</li>
</ul>
</li>
<li><p>通过多重继承，子类可以获得多个父类的所有功能，而为了提高代码的可读性，加入了Mixln这种常见设计。</p>
</li>
<li><p>@property</p>
<ul>
<li><p>把一个getter方法变成属性，只需要加上@property</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self._score</span><br></pre></td></tr></table></figure>
</li>
<li><p>@xxx.setter,负责把一个setter方法变成属性赋值。（xxx与property下的方法同名）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@score.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">score</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(value, int):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'score must be an integer!'</span>)</span><br><span class="line">    <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'score must between 0 ~ 100!'</span>)</span><br><span class="line">    self._score = value</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>一些定制类</p>
<ul>
<li><p>__ str __</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Student object (name=%s)'</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>
</li>
<li><p>__ iter __</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__ getitem __     <em>还可以加很多</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
</li>
<li><p>__ getattr __      <em>动态返回一个属性</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'Michael'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, attr)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> attr==<span class="string">'score'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">99</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>__ call __         <em>任何类中定义后，就可以直接对实例进行调用</em></p>
</li>
</ul>
</li>
<li><p>Enum</p>
<ul>
<li>可以把一组相关常量定义在一个class中，且class不可变，而且成员可以直接比较。</li>
<li>枚举类型不可实例化，不可更改。</li>
<li>定义枚举时，成员名不允许重复。</li>
<li>成员值允许相同，第二个成员的名称被视作第一个成员的别名。</li>
<li>若要不能定义相同的成员值，可以通过unique装饰。</li>
<li>IntEnum时Enum的拓展，不同类型的整数枚举可以相互比较。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟叔基础篇笔记</title>
    <url>/2020/03/20/%E9%B8%9F%E5%8F%94%E5%9F%BA%E7%A1%80%E7%AF%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><p>man page中DATE（num）num对应的内容：</p>
<a id="more"></a>

</li>
</ul>
<table>
<thead>
<tr>
<th>代号</th>
<th>代表内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><strong>使用者在shell环境中可以操作的指令或可执行文件</strong></td>
</tr>
<tr>
<td>2</td>
<td>系统核心可调用的函数与工具等</td>
</tr>
<tr>
<td>3</td>
<td>一些常用的函数与函数库，大部分为C的函数库</td>
</tr>
<tr>
<td>4</td>
<td>设备文件的说明，通常在/dev下的文件</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><strong>配置文件或者是某些文件的格式</strong></td>
</tr>
<tr>
<td>6</td>
<td>游戏</td>
</tr>
<tr>
<td>7</td>
<td>惯例与协定等，例如Linux文件系统、网络协定、ASCII code等等的说明</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><strong>系统管理员可用的管理指令</strong></td>
</tr>
<tr>
<td>9</td>
<td>跟kernel有关的文件</td>
</tr>
</tbody></table>
<ul>
<li>三大工具：<ul>
<li>man</li>
<li>info</li>
<li>/usr/share/doc/</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu科学上网最终解决方案</title>
    <url>/2020/03/14/Ubuntu%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h4 id="尝试改变系统网络设置，但最终还是不行，所以，最终方案就是"><a href="#尝试改变系统网络设置，但最终还是不行，所以，最终方案就是" class="headerlink" title="尝试改变系统网络设置，但最终还是不行，所以，最终方案就是"></a>尝试改变系统网络设置，但最终还是不行，所以，最终方案就是</h4><a id="more"></a>

<hr>
<p>重新安装Ubuntu系统之后，重新安装electron-ssr，之后就可以了。</p>
<p><a href="https://www.cnblogs.com/masbay/p/10745170.html" target="_blank">双系统安装教程</a></p>
<p><a href="https://blog.csdn.net/qq_15192373/article/details/81536602" target="_blank">双系统完全删除Ubuntu教程</a></p>
]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>学习c++的一些笔记</title>
    <url>/2020/03/05/%E5%AD%A6%E4%B9%A0cpp%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><ul>
<li>大部分内容c都有，引入类的概念</li>
</ul>
<h3 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h3><a id="more"></a>

<p><strong><em>类型是编程的基础</em></strong></p>
<hr>
<ul>
<li><p>选择类型的经验准则</p>
<ul>
<li>当明确知道数值不可能为负时，选用无符号类型。</li>
<li>使用int执行整数运算。</li>
<li>在算数表达式中不要使用char或bool，只有在存放字符或布尔值时才用它们。</li>
<li>执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。</li>
</ul>
</li>
<li><p>定义在函数体内部的内置类型变量将<strong>不被初始化</strong> </p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> local_int;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>指针和引用的区别</p>
<ul>
<li>指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；引用不是一个对象，无法令引用重新绑定到另外一个对象。</li>
<li>指针无须再定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值；引用则必须在定义时赋初值。</li>
</ul>
</li>
<li><p>顶层const</p>
<ul>
<li>顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。</li>
<li>底层const则与指针和引用等符合类型的基本类型部分有关。</li>
<li>特殊的是，指针既可以是顶层const又可以是底层const。</li>
<li>auto一般会忽略掉顶层const，同时底层const则会保留下来。</li>
<li>执行对象的拷贝操作时，常量时顶层const还是底层const区别明显。<ul>
<li>顶层const不受什么影响，执行拷贝操作并不会改变拷贝对象的值。</li>
<li>底层const的限制不能忽视，当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层cosnt资格。或者两个对象的数据类型必须能够转换。</li>
</ul>
</li>
</ul>
</li>
<li><p>指针和constexpr</p>
<ul>
<li>限定符constexpr仅对指针有效，与指针所指的对象无关。</li>
</ul>
</li>
<li><p>类型别名的易错点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pstring cstr=<span class="number">0</span>;<span class="comment">//cstr是指向char的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * cstr=<span class="number">0</span>;<span class="comment">//cstr是指向常量char的指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>auto的一些知识点</p>
<ul>
<li>赋值式子中的右值是引用时，以引用对象的类型作为auto的类型。</li>
<li>auto一般会忽略掉顶层const，同时底层const会保留下来。（顶层const需要明确指出）</li>
<li>要在一条语句中定义多个变量，初始值必须是同一种类型。</li>
</ul>
</li>
<li><p>decltype</p>
<ul>
<li><p>作用：选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型。但不实际计算表达式的值。</p>
</li>
<li><p>与auto不同的地方：如果decltype使用的表达式是一个变量，则返回该变量的类型。（*<em>引用 *</em>）</p>
</li>
<li><p>decltype和引用</p>
<ul>
<li>表达式内容是解引用操作，则得到引用类型。</li>
<li>decltype<strong>((</strong>variable<strong>))</strong>的结果永远是引用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第三章-字符串、向量和数组"><a href="#第三章-字符串、向量和数组" class="headerlink" title="第三章 字符串、向量和数组"></a>第三章 字符串、向量和数组</h3><p><strong><em>优先选用标准库提供的类型，之后再考虑c++内置的低层的替代品数组或指针</em></strong></p>
<hr>
<ul>
<li><p>string  <strong>可变长字符序列</strong></p>
<ul>
<li>string和字符串字面值不一样。</li>
<li>cctype头文件中有很多函数。</li>
</ul>
</li>
<li><p>vector  <strong>一组同类型对象的容器</strong></p>
<ul>
<li>是一个“<strong>容纳着</strong>”其他对象的<strong>容器</strong>。</li>
<li>常见方法是先定义一个空vector，当运行时获取到元素的值后再逐一添加。<strong>push_back</strong>。</li>
<li>vector能高效增长。</li>
<li>通过下标访问不存在的元素会导致缓冲区溢出。</li>
</ul>
</li>
<li><p>迭代器</p>
<ul>
<li><p>名词本身有三种不同的含义</p>
<ul>
<li>迭代器概念本身</li>
<li>容器定义的迭代器类型</li>
<li>某个迭代器对象</li>
</ul>
</li>
<li><p>使用了迭代器的循环体，都不要向迭代器所属的容器添加元素</p>
</li>
</ul>
</li>
<li><p>数组</p>
<ul>
<li>使用数组作为一个auto变量的初始值时，推断得到的类型时指针；而使用decltype关键字时返回的类型则是数组。</li>
<li>内置的下标运算符所用的索引值不是无符号类型。</li>
<li>可以使用数组来初始化vector对象。</li>
</ul>
</li>
</ul>
<h3 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h3><ul>
<li><p>左值和右值</p>
<ul>
<li>当一个对象被用作<strong>右值</strong>的时候，用的是对象的值（内容）；当对象被用作<strong>左值</strong>的时候，用的是对象的身份（在内存中的位置）。</li>
<li>在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）来使用。</li>
</ul>
</li>
<li><p>短路求值</p>
<ul>
<li>对于&amp;&amp;，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li>
<li>对于||，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li>
</ul>
</li>
<li><p>若某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小。</p>
</li>
<li><p>命名的强制类型转换 <em>尽量避免</em></p>
<ul>
<li>static_cast</li>
</ul>
</li>
<li><p>任何具有明确定义的不包含底层const的类型转换</p>
</li>
<li><p>const_cast</p>
<ul>
<li><p>只能改变运算对象的底层const，称为“<strong>去掉const性质</strong>”，但是，<strong>对声明为const的变量来说，常量就是常量，无论怎么转化，常量的值就是不会变。</strong></p>
</li>
<li><p>const_cast的用法：</p>
<ul>
<li><p>若有一个函数，它的形参是non_const类型变量，而且函数不会对实参的值进行改动。这是我们可以使用类型为const的变量来调用函数，此时const_cast就派上用场了。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputInt</span><span class="params">(<span class="keyword">int</span> * num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> constant = <span class="number">21</span>;</span><br><span class="line">    <span class="comment">//InputInt(constant); //error C2664: “InputInt”: 不能将参数 1 从“const int”转换为“int *”</span></span><br><span class="line">    InputInt(<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;constant));</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们定义了一个非const的变量，却使用了一个指向const值的指针来指向它，const_cast就可以派上用场。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> constant = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* const_p = &amp;constant;</span><br><span class="line">    <span class="keyword">int</span>* modifier = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(const_p);</span><br><span class="line">    *modifier = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"constant:  "</span>&lt;&lt;constant&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*modifier:  "</span>&lt;&lt;*modifier&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>const_cast不是为了改变const变量的值而设计的，在函数参数的传递上const_cast的作用上const_cast的作用才显现出来。</strong></p>
</li>
</ul>
</li>
<li><p>reinterpret_cast  <strong>依赖于机器</strong></p>
<ul>
<li>通常为运算对象的位模式提供较低层次上的重新解释。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h3><p><strong><em>语句有限</em></strong></p>
<hr>
<ul>
<li>while、for和do while语句，执行迭代操作。</li>
<li>if和switch语句，提供条件分支结构。</li>
<li>continue语句，终止循环的当前一次迭代。</li>
<li>break语句，退出循环或者switch语句。</li>
<li>goto语句，将控制权转移到一条带标签的语句。<strong>一般不用</strong></li>
<li>try和catch，将一段可能发生异常的语句序列在花括号里构成try语句块，catch子句负责处理代码抛出的异常。<strong>一个抛一个接</strong></li>
<li>throw表达式语句，存在于代码块中，将控制权转移到相关的catch子句中。</li>
<li>return语句，终止函数的执行。</li>
</ul>
<h3 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h3><ul>
<li><p>使用引用类型的形参替代指针，若函数无需改变引用形参的值，最好将其声明为常量引用。</p>
</li>
<li><p>C++允许定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别</p>
</li>
<li><p>编写能处理不同数量实参的函数，C++11提供了两个主要的方法：</p>
<ul>
<li><p>若所有的实参类型相同，可以传递一个名为initializer_list的标准库类型。</p>
</li>
<li><p>若实参类型不同，可以编写一种特殊的函数，也就是所谓的可变参数模板。<strong>16章</strong></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>返回数组指针</p>
<ul>
<li>使用decltype</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure>

<ul>
<li>位置返回类型</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto func(int i) -&gt; int(*)[10]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数重载和const形参</p>
<ul>
<li><p>顶层const不影响传入函数的对象。<em>一个拥有四年高层xonst的形参无法和另一个没有顶层const的形参区分开。</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;<span class="comment">//重复声明了Record lookup(Phone)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>内联函数<strong>inline</strong></p>
<ul>
<li>将函数再每个调用点上“内联地”展开。</li>
<li>内敛说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</li>
</ul>
</li>
<li><p>constexpr函数 <em>用于常量表达式</em></p>
<ul>
<li>函数的返回类型及所有形参的类型都得是字面值类型</li>
<li>函数体中有且只有一条return语句。也可以包含其他语句，只要这些语句在运行时不执行任何操作。</li>
</ul>
</li>
</ul>
<h3 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h3><ul>
<li><p>隐形this指针</p>
<ul>
<li>静态成员函数不能使用this指针，因为静态成员函数并不具体作用于某个对象–&gt;静态成员函数的真实的参数的个数，就是程序中写出的参数个数。</li>
</ul>
</li>
<li><p>常量成员函数</p>
</li>
<li><p>构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s) : bookNo(s)&#123;&#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p) : bookNo(s), units_sold(n), revenue(p*n) &#123;&#125;</span><br><span class="line">Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>使用class和struct定义类唯一的区别就是默认的访问权限。</p>
<ul>
<li>如果希望定义的类的所有成员是public的时候使用struct。</li>
<li>如果希望成员是private的时候，使用class。</li>
</ul>
</li>
<li><p><strong>友元</strong>可以使其他类或函数访问该类的非公有成员，<em>使用不慎就有可能破坏类的封装性。</em></p>
<ul>
<li>友元声明只能出现在类定义的内部，一般最好在类定义开始或结束前的位置集中声明友元。</li>
<li>友元不是类的成员也不受它所在区域访问控制级别的约束。</li>
</ul>
</li>
<li><p>封装的益处：</p>
<ul>
<li>确保用户代码不会无意间破坏封装对象的状态。</li>
<li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li>
</ul>
</li>
<li><p>析构函数（先初始化的后析构</p>
<ul>
<li>名字与类名相同，在前面加’~’。</li>
<li>当一个对象生命周期结束时，其所占有的内存空间就要被回收，这个工作就由析构函数来完成。</li>
<li><strong>析构函数是“反向”的构造函数，析构函数不允许有返回值，更重要的是析构函数不允许带参数，并且一个类中只能由一个析构函数。</strong></li>
</ul>
</li>
<li><p>析构函数的作用正好与构造函数相反，对象超出其作用范围，对应的内存空间被系统收回或被程序delete删除时，析构函数被调用。</p>
<ul>
<li>根据析构函数的这种特点，我们可以在构造函数中初始化对象的某些成员变量，给其分配内存空间（堆内存），在析构函数中释放对象运行期间所申请的资源。</li>
<li>delete运算导致析构函数调用，new出来的东西一定要用delete才会消亡。</li>
</ul>
</li>
<li><p>可变数据类型<strong>mutable data member</strong></p>
</li>
<li><p>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</p>
</li>
<li><p>复制构造函数起作用的三种情况：</p>
<ul>
<li><p>当用一个对象去初始化同类的另一个对象时。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c2</span><span class="params">(c1)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果有某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用。</p>
</li>
<li><p>如果函数的返回值是类A的对象时，则函数返回时，A的复制构造函数被调用。</p>
</li>
</ul>
</li>
<li><p>常量引用参数的使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(CMyclass obj_)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"fun"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这样的函数调用时生成形参会引发复制构造函数调用，开销较大，所以可以考虑使用CMyclass&amp;引用类型作为参数。</p>
</li>
<li><p>如果希望确保实参的值在函数中不应被改变，那么可以加上const关键字：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> CMyclass &amp; obj)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数中任何试图改变obj值的语句都将是非法的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>类型转换构造函数（实现类型的自动转换</p>
</li>
<li><p>静态成员（不需要通过对象就能访问</p>
<p><strong><em>设置静态成员的机制的目的是将和某些类紧密相关的全局变量和函数写到类里面，看上去像一个整体，易于维护和理解。</em></strong></p>
<ul>
<li>静态成员变量<ul>
<li>一共只有一份，<strong>为所有对象共享。</strong></li>
<li>sizeof不会计算静态成员变量。</li>
<li>本质上是全局变量，哪怕一个对象也不存在，静态成员变量也存在</li>
</ul>
</li>
<li>静态成员函数<ul>
<li><strong>并不具体作用于某个对象。</strong></li>
<li>本质上是全局函数。</li>
<li><strong>在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数。</strong> </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>任何生成封闭类对象的语句，都要让编译器明白，对象中的成员对象，是如何初始化的。</strong></p>
<ul>
<li>具体的做法就是：<strong>通过封闭类的构造函数的初始化列表。</strong></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
